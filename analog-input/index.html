<!Doctype html>
<html class="no-js" lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>ANALOG INPUTS (ANALOG TO DIGITAL CONVERTER) - QEEWiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <meta name="description" content="Guide For Working With AVR Microcontrollers"/>
    <meta name="keywords"
          content="atmega8, atmega168, atmega328, atmega328p, interrupt, timer, adc, analog comparator, pwm, fast pwm, phase correct pwm, spi, uart, i2c, eeprom, tutorial, datasheet"/>
    <meta name="author" content="Chayan Mistry">

    <meta property="og:url" content="https://avr-guide.github.io"/>
    <meta property="og:site_name" content="AVR GUIDE - QEEWiki"/>
    <link rel="icon" href="../assets/img/favicon.ico">

    <!-- Place favicon.ico in the root directory -->
    <link rel="stylesheet" href="../assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="../assets/css/responsive.css">
    <link rel="stylesheet" href="../assets/css/prettify.css">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L8GR6MPRF3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-L8GR6MPRF3');
    </script>
</head>
<body>

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="check2" viewBox="0 0 16 16">
        <path
                d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path>
    </symbol>
    <symbol id="circle-half" viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path>
    </symbol>
    <symbol id="moon-stars-fill" viewBox="0 0 16 16">
        <path
                d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path>
        <path
                d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path>
    </symbol>
    <symbol id="sun-fill" viewBox="0 0 16 16">
        <path
                d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path>
    </symbol>
</svg>

<div id="wrapper">
    <div class="wrap-container ">
        <header class="navbar">
            <h4>
                <a href="/">QEEWiki</a>
                <button class="navbar-toggler d-block d-md-none" type="button" data-bs-toggle="offcanvas"
                        data-bs-target="#offcanvasNavbar" aria-controls="offcanvasNavbar"
                        aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </h4>
        </header>
        <div class="d-flex">
            <nav class="navbar" id="sidebar">
                <div class="container-fluid px-md-0">
                    <div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasNavbar"
                         aria-labelledby="offcanvasNavbarLabel">
                        <div class="offcanvas-header border-bottom d-flex d-md-none">
                            <h5 class="offcanvas-title" id="offcanvasNavbarLabel">QEEWiki</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="offcanvas"
                                    aria-label="Close"></button>
                        </div>
                        <div class="offcanvas-body px-md-0 pt-0">
                            <ul class="navbar-nav justify-content-end flex-grow-1">
                                <li class="nav-item">
                                    <b>Navigation</b>
                                    <ul>
                                        <li><a href="https://chayanforyou.github.io/">Home</a></li>
                                        <li class="nav-item dropdown">
                                            <a class="nav-link dropdown-toggle show" role="button"
                                               data-bs-toggle="dropdown"
                                               aria-expanded="true">
                                                AVR Guide
                                            </a>
                                            <ul class="dropdown-menu show ">
                                                <li><a class="dropdown-item" href="#">AVR Basics</a></li>
                                                <li><a class="dropdown-item" href="#">Digital I/O</a></li>
                                                <li><a class="dropdown-item" href="/#interrupts">Interrupts</a></li>
                                                <li><a class="dropdown-item" href="#">Timers</a></li>
                                                <li><a class="dropdown-item" href="#">Analog I/O</a></li>
                                                <li><a class="dropdown-item" href="#">Communication</a></li>
                                                <li><a class="dropdown-item" href="#">Other</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#">Usefull Engineering Stuff</a></li>
                                    </ul>
                                </li>
                                <li class="nav-item">
                                    <b>Resources</b>
                                    <ul>
                                        <li><a href="https://www.sparkfun.com/">Sparkfun</a></li>
                                        <li><a href="https://arduino.cc/en/Reference/HomePage">Arduino Reference</a>
                                        </li>
                                        <li><a href="https://www.eevblog.com/">EEVBlog</a></li>
                                        <li><a href="https://tahmidmc.blogspot.com/">Tahmid's Blog</a></li>
                                        <li><a href="https://labprojectsbd.com/">Lab Projects BD</a></li>
                                        <li class="nav-item dropdown">
                                            <a class="nav-link dropdown-toggle show" role="button" aria-expanded="true">Atmel</a>
                                            <ul class="dropdown-menu show ">
                                                <li><a class="dropdown-item" href="/assets/docs/ATmega8A.pdf"
                                                       target="_blank" rel="nofollow">Atmega8 Datasheet</a></li>
                                                <li><a class="dropdown-item"
                                                       href="/assets/docs/ATmega48A-PA-88A-PA-168A-PA-328-P.pdf"
                                                       target="_blank" rel="nofollow">ATMega168/328 Datasheet</a></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </nav>
            <main id="contentBox">

                <nav aria-label="breadcrumb" id="breadcrumb">
                    <ol class="breadcrumb">
                        <li class="breadcrumb-item"><a href="#">AVR Guide</a></li>
                        <li class="breadcrumb-item"><a href="#">Analog I/O</a></li>
                    </ol>
                </nav>

                <div class="main-content">
                    <h3>ANALOG INPUTS (ANALOG TO DIGITAL CONVERTER)</h3>
                    <br/>
                    <h5 class="fw-semibold">INTRODUCTION:</h5>
                    <div class="chapter ms-4 pt-2">
                        <p>
                            Digital inputs are great, but sometimes devices output an analog signal. An analog signal is
                            a signal of varying voltage levels. Temperature sensors, light sensors, potentiometers and
                            flex sensors are just some of the devices that output analog voltages that the AVR could
                            read. Analog sensors are generally a resistor that changes its value when a given condition
                            is met (light level, temperature, flexibility, stretching ... etc.).
                        </p>
                        <p>
                            This is by far my favorite part of the AVR because you could find so many uses for it.
                        </p>
                    </div>

                    <hr class="mb-4"/>
                    <h5 class="fw-semibold">HARDWARE:</h5>
                    <div class="chapter ms-4 py-2">
                        <img class="img-fluid mt-3" src="/analog-input/ATmega8 - ADC.JPG" alt="ATmega8 - ADC">
                        <p class="fw-light">Figure 1: ATmega8 - ADC Pins</p>
                        <p>
                            Different AVRs have a different number of analog Inputs the ATmega8 and the ATmega168/328
                            has 6 different device pins but only 1 ADC (Analog to Digital Converter) converter. The 6
                            input pins are connected to a multiplexer which basically allows a single input to be
                            connected to the ADC in order to get a reading. So we have to be smart about how to use our
                            ADC and how to prioritize our readings.
                        </p>
                        <p>
                            The data sheet on the ADC can be a bit overwhelming, it talks about timing, noise
                            cancellation, filters, uses inductors and is 10 bit ... 10 bit! I mean come on. The truth is
                            that it is not as complicated as it may seem. Most of us hobbyists do not need a NASA level
                            of precision. Lets do some quick math, 90% of the time we will use 5V, the ADC is a 10bit
                            ADC so this means it can do 1024 bits of resolution. 5V / 1024 ~= 0.005V. We will never need
                            that kind of accuracy. All we really need is a small capacitor or 2 and we are good to go.
                        </p>
                        <img class="img-fluid mt-3" src="/analog-input/ADC - Power Hookup.JPG" alt="ADC - Power Hookup">
                        <p class="fw-light">Figure 2: Recommended ADC Power Hookup</p>
                        <p>
                            If you want to be fancy you can add a 10uH inductor for extra filtering between the AVCC pin
                            and Vcc (5V on the schematic). Most hobbyist's however, don't bother. Lastly, most
                            hobbyist's don't bother with C2 and simply leave AREF disconnected. I however, have had a
                            lot of luck with a nice stable ADC using the schematic above.
                        </p>
                        <img class="img-fluid mt-3" src="/analog-input/ADC - Sensor Hookup 1.JPG"
                             alt="ADC - Sensor Hookup 1">
                        <p class="fw-light">Figure 3: 3-pin Analog Sensor Hookup</p>
                        <p>
                            In order for an analog sensor to work, it must create some sort of voltage divider. 3 pin
                            type sensors that have a GND, VCC and Output connection have a voltage divider build in and
                            can be connected to an ADC pin directly as per Figure 3.
                        </p>
                        <img class="img-fluid mt-3" src="/analog-input/ADC - Sensor Hookup 2.JPG"
                             alt="ADC - Sensor Hookup 2">
                        <p class="fw-light">Figure 4: 2-pin Analog Sensor Hookup</p>
                        <p>
                            2 pin type sensors on the other hand work by changing their resistance and will not work
                            without the use of a resistor (because you need a minimum of 2 resistors to build a voltage
                            divider network. You could use any value for R1 but you have to make sure that you do not
                            cause a short circuit and/or that it doesn't snuff out (for a lack of a better term) your
                            sensor.
                        </p>

                        <p class="fw-semibold mt-4">2 Pin Resistive Type Sensor Calculations:</p>
                        <p>
                            Ok this section has a bit of math, so if your not interested here is a shorthand rule. Make
                            R1 the same value as the highest value of the sensor. This gives you the best power to
                            sensor voltage range ratio. The rest of this subsection just proves that statement.
                        </p>
                        <p>
                            I use 2 calculations to make sure the Resistor value will work out well. Max current draw
                            and the Difference in voltage between sensor min and max.
                        </p>
                        <p>
                            If you think back to V=IR, dropping the resistance will cause your current to rise if your
                            voltage stays the same. So if we add the value of R1 and the lowest value of our sensor
                            together we will find the highest current draw for our sensor. We also have to figure out
                            the difference in voltage between the highest and lowest sensor resistance value to figure
                            out your window, the bigger the window the more data the higher your resolution.
                        </p>
                        <p>
                            So lets use the <a href="https://www.sparkfun.com/products/9088" target="_blank"
                                               rel="nofollow">Mini Photocell</a> from <a href="https://www.sparkfun.com"
                                                                                         target="_blank" rel="nofollow">Sparkfun</a>as
                            our sensor. It ranges form 1k - 10k Ohms:
                        </p>

                        <div class="table-responsive mt-4">
                            <table class="table table-bordered max-width-600">
                                <thead>
                                <tr>
                                    <th>Using 1k Resistor</th>
                                    <th>Using 10k Resistor</th>
                                    <th>Using 1M Resistor</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td style="color:blue">
                                        V = I * R<br>
                                        I = V / R<br>
                                        I = V / (R1 + R_sensorlow)<br>
                                        I = 5 / (1k + 1k)<br>
                                        I = 5 / 2k<br>
                                        I = 2.5 mA
                                    </td>
                                    <td style="color:blue">
                                        V = I * R<br>
                                        I = V / R<br>
                                        I = V / (R1 + R_sensorlow)<br>
                                        I = 5 / (10k + 1k)<br>
                                        I = 5 / 11k<br>
                                        I = 0.45 mA
                                    </td>
                                    <td style="color:blue">
                                        V = I * R<br>
                                        I = V / R<br>
                                        I = V / (R1 + R_sensorlow)<br>
                                        I = 5 / (1M + 1k)<br>
                                        I = 5 / 1001k<br>
                                        I = 4.5 mA
                                    </td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="mt-4">
                            Notice how we use 5 times less power if we use the 10k resistor over the 1k, and the 1 Ohm
                            uses 10 times more power then the 10k. Another thing to note, is that if your using 1/8th
                            watt resistors you will be limited to 25mA @ 5V so knowing how much current your sensors
                            draw isn't a stupid idea.
                        </p>
                        <p>
                            Now for the resolution calculation. We do some hard math or we could just create 2 voltage
                            divider networks, 1 using the min value of the sensor and the other using the max values,
                            and then subtract the difference to get our working voltage range.
                        </p>

                        <div class="table-responsive mt-4">
                            <table class="table table-bordered max-width-650">
                                <thead>
                                <tr>
                                    <th>1k Resistor Min Sens R</th>
                                    <th>1k Resistor Max Sens R</th>
                                    <th>Conclusion</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td style="color:blue">
                                        Vout = R2 / (R1 + R2) * Vcc<br>
                                        Vout = 1k / (1k+1k) *5V<br>
                                        Vout = 1k / 2k * 5V<br>
                                        Vout = 2.5V
                                    </td>
                                    <td style="color:blue">
                                        Vout = R2 / (R1 + R2) * Vcc<br>
                                        Vout = 10k / (1k + 10k) * 5V<br>
                                        Vout = 10k / 11k * 5V<br>
                                        Vout = 4.5V
                                    </td>
                                    <td style="color:blue">
                                        Using a 1k Resistor the Photocell has a<br>
                                        2V difference between Min and Max.
                                        <br><br>
                                        Min 2.5V sensed<br>
                                        Max 4.5V sensed
                                    </td>
                                </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="table-responsive mt-4">
                            <table class="table table-bordered max-width-650">
                                <thead>
                                <tr>
                                    <th>10k Resistor Min Sens R</th>
                                    <th>10k Resistor Max Sens R</th>
                                    <th>Conclusion</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td style="color:blue">
                                        Vout = R2 / (R1 + R2) * Vcc<br>
                                        Vout = 1k / (10k+1k) * 5V<br>
                                        Vout = 1k / 11k * 5V<br>
                                        Vout = 0.45V
                                    </td>
                                    <td style="color:blue">
                                        Vout = R2 / (R1 + R2) * Vcc<br>
                                        Vout = 10k / (10k + 10k) * 5V<br>
                                        Vout = 10k / 20k * 5V<br>
                                        Vout = 2.5V
                                    </td>
                                    <td style="color:blue">
                                        Using a 10k Resistor the Photocell has a<br>
                                        2V difference between Min and Max.
                                        <br><br>
                                        Min 0.45V sensed<br>
                                        Max 2.5V sensed
                                    </td>
                                </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="table-responsive mt-4">
                            <table class="table table-bordered max-width-650">
                                <thead>
                                <tr>
                                    <th>1M Resistor Min Sens R</th>
                                    <th>1M Resistor Max Sens R</th>
                                    <th>Conclusion</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td style="color:blue">
                                        Vout = R2 / (R1 + R2) * Vcc<br>
                                        Vout = 1k / (1M+1k) * 5V<br>
                                        Vout = 1k / 1001k * 5V<br>
                                        Vout = 0.0049V
                                    </td>
                                    <td style="color:blue">
                                        Vout = R2 / (R1 + R2) * Vcc<br>
                                        Vout = 10k / (1M + 10k) * 5V<br>
                                        Vout = 10k / 1010k * 5V<br>
                                        Vout = 0.049
                                    </td>
                                    <td style="color:blue">
                                        Using a 1M Resistor the Photocell has a<br>
                                        0.04V difference between Min and Max.
                                        <br><br>
                                        So our resolution has really shrunk
                                    </td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="mt-4">
                            I was always thought in school to have a conclusion for complicated or long example, so here
                            it is, If your resistor is too low, you risk an overload and use more power, if its too high
                            you will lose resolution. Using the min value of your resistive sensor will come up to the
                            same resolution as using your max value, so use the max value (since higher R means less I).
                        </p>

                        <p class="fw-semibold mt-4">Signal Noise:</p>
                        <p>
                            Our air filled with Electra-Magnetic noise; Radio waves, wireless networks power lines all
                            emit electro-magnetic noise. This noise can be picked up by the ADC because the traces on
                            the circuit board and any wires between the board and sensor will act like an antenna and
                            pickup this noise. The longer the antenna the greater the noise. So when your designing your
                            circuit board make sure to keep the traces from the ADC as short as possible to reduce
                            noise. But what if your sensor needs to be far away from your board? Well you could use some
                            fancy programming to try to "guesstimate" the true signal of you could use a shielded cable.
                        </p>
                        <p>
                            Shielded cables have a ... well shield around the conductors that will keep the noise from
                            being felt by the conductors. The shield is a metal braid (or foil) material that surrounds
                            the wires. Any magnetic noise that comes from the air will be captured by the shield.
                        </p>
                        <img class="img-fluid mt-3" src="/analog-input/shielded Wire.JPG" alt="shielded Wire">
                        <p class="fw-light">Figure 5: Shielded Cable</p>
                        <p>
                            In order to make this work, you have to connect the shield to the ground BUT only one 1 end.
                            Connecting both ends of a shield to ground could cause ground loop faults. If you ever
                            hooked up a high end stereo system and have heard hum coming from the speakers, you have
                            heard a ground fault loop in action.
                        </p>

                        <p class="fw-semibold mt-4">Using the ADC For Extra Buttons:</p>
                        <p>
                            This is a really cool trick, Say you want to build something, but you don't have enough
                            Digital Inputs. If you build a voltage divider network and use the buttons to short out the
                            resistors you could read use the ADC to figure out what button was pressed. The downsides to
                            doing this is that it takes a lot more time to read an ADC than it does to read a Digital
                            Input and that you could not read multiple keys being pressed at the same time.
                        </p>
                        <img class="img-fluid mt-3" src="/analog-input/ADC - Multi Button.JPG" alt="ADC - Multi Button">
                        <p class="fw-light">Figure 6: Multiple Buttons On the ADC</p>
                    </div>

                    <hr class="mt-4 mb-4"/>
                    <h5 class="fw-semibold">THEORY OF OPERATION:</h5>
                    <div class="chapter ms-4 py-2">
                        <div class="table-responsive mt-4">
                            <table class="table table-bordered text-center max-width-600">
                                <thead>
                                <tr>
                                    <th></th>
                                    <th>7 bit</th>
                                    <th>6 bit</th>
                                    <th>5 bit</th>
                                    <th>4 bit</th>
                                    <th>3 bit</th>
                                    <th>2 bit</th>
                                    <th>1 bit</th>
                                    <th>0 bit</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <th>ADMUX</th>
                                    <td>REFS1</td>
                                    <td>REFS0</td>
                                    <td>ADLAR</td>
                                    <td class="disable-cell">-</td>
                                    <td>MUX3</td>
                                    <td>MUX2</td>
                                    <td>MUX1</td>
                                    <td>MUX0</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light">ADC Multiplexer Selection Register</p>

                        <div class="table-responsive mt-4 ms-4">
                            <table class="table table-bordered max-width-600">
                                <tbody>
                                <tr>
                                    <th>REFS1</th>
                                    <th>REFS0</th>
                                    <th>Voltage Reference Selection</th>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td>AREF, Internal Vref turned off</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td>AVcc with external capacitor on AREF pin</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td>Reserved</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td>Internal 1.1V (ATmega168/328) or 2.56V on (ATmega8)</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light ms-4">REF Bits</p>

                        <div class="table-responsive mt-4 ms-4">
                            <table class="table table-bordered max-width-600">
                                <tbody>
                                <tr>
                                    <th>MUX 3...0</th>
                                    <th>Single Ended Input</th>
                                </tr>
                                <tr>
                                    <td>0000</td>
                                    <td>ADC0</td>
                                </tr>
                                <tr>
                                    <td>0001</td>
                                    <td>ADC1</td>
                                </tr>
                                <tr>
                                    <td>0010</td>
                                    <td>ADC2</td>
                                </tr>
                                <tr>
                                    <td>0011</td>
                                    <td>ADC3</td>
                                </tr>
                                <tr>
                                    <td>0100</td>
                                    <td>ADC4</td>
                                </tr>
                                <tr>
                                    <td>0101</td>
                                    <td>ADC5</td>
                                </tr>
                                <tr>
                                    <td>0110</td>
                                    <td>ADC6</td>
                                </tr>
                                <tr>
                                    <td>0111</td>
                                    <td>ADC7</td>
                                </tr>
                                <tr>
                                    <td>1000</td>
                                    <td>Temp Sensor (ATmega168/328 only)</td>
                                </tr>
                                <tr>
                                    <td>1001 - 1101</td>
                                    <td>(reserved)</td>
                                </tr>
                                <tr>
                                    <td>1110</td>
                                    <td>1.1V (ATmega168/328) 1.30V (ATmega8)</td>
                                </tr>
                                <tr>
                                    <td>1111</td>
                                    <td>0V (GND)</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light ms-4">MUX Bits</p>

                        <span style="background: yellow" class="fw-bold">
                            If ADLAR in the ADMUX Register is LOW (0)
                        </span>
                        <div class="table-responsive">
                            <table class="table table-bordered text-center max-width-600">
                                <thead>
                                <tr>
                                    <th></th>
                                    <th>7 bit</th>
                                    <th>6 bit</th>
                                    <th>5 bit</th>
                                    <th>4 bit</th>
                                    <th>3 bit</th>
                                    <th>2 bit</th>
                                    <th>1 bit</th>
                                    <th>0 bit</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <th>ADCH</th>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td>ADC9</td>
                                    <td>ADC8</td>
                                </tr>
                                <tr>
                                    <th>ADCL</th>
                                    <td>ADC7</td>
                                    <td>ADC6</td>
                                    <td>ADC5</td>
                                    <td>ADC4</td>
                                    <td>ADC3</td>
                                    <td>ADC2</td>
                                    <td>ADC1</td>
                                    <td>ADC0</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light">ADC Data Register</p>

                        <span style="background: yellow" class="fw-bold">
                            ADLAR in the ADMUX Register is HIGH (1)
                        </span>
                        <div class="table-responsive">
                            <table class="table table-bordered text-center max-width-600">
                                <thead>
                                <tr>
                                    <th></th>
                                    <th>7 bit</th>
                                    <th>6 bit</th>
                                    <th>5 bit</th>
                                    <th>4 bit</th>
                                    <th>3 bit</th>
                                    <th>2 bit</th>
                                    <th>1 bit</th>
                                    <th>0 bit</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <th>ADCH</th>
                                    <td>ADC9</td>
                                    <td>ADC8</td>
                                    <td>ADC7</td>
                                    <td>ADC6</td>
                                    <td>ADC5</td>
                                    <td>ADC4</td>
                                    <td>ADC3</td>
                                    <td>ADC2</td>
                                </tr>
                                <tr>
                                    <th>ADCL</th>
                                    <td>ADC1</td>
                                    <td>ADC0</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light">ADC Data Register</p>

                        <div class="table-responsive mt-4">
                            <table class="table table-bordered text-center max-width-600">
                                <thead>
                                <tr>
                                    <th></th>
                                    <th>7 bit</th>
                                    <th>6 bit</th>
                                    <th>5 bit</th>
                                    <th>4 bit</th>
                                    <th>3 bit</th>
                                    <th>2 bit</th>
                                    <th>1 bit</th>
                                    <th>0 bit</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <th>ADCSRA</th>
                                    <td>ADEN</td>
                                    <td>ADSC</td>
                                    <td>ADFR*</td>
                                    <td>ADIF</td>
                                    <td>ADIE</td>
                                    <td>ADPS2</td>
                                    <td>ADPS1</td>
                                    <td>ADPS0</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <span style="color: red">NOTE * ADATE in ATmega168/328, ADFR in ATmega8</span>
                        <p class="fw-light">ADC Control and Status Register A</p>

                        <div class="table-responsive mt-4 ms-4">
                            <table class="table table-bordered max-width-400">
                                <tbody>
                                <tr>
                                    <th>ADPS2</th>
                                    <th>ADPS1</th>
                                    <th>ADPS0</th>
                                    <th>Division Factor</th>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">2 *</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">2</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">4</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">8</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">16</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">32</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">64</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">128</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light ms-4">ADPS Bits</p>
                        <p class="fst-italic fw-light ms-4">* not a typo, check datasheet if you don't believe me :P</p>

                        <p class="fw-semibold mt-4">Reference Voltage Sources:</p>
                        <p>
                            The first thing we need to do is select a reference source (this is the high voltage) using
                            the REFS1 and REFS0 bits in the ADMUX register. We could chose to use the voltage on the
                            AREF pin, this voltage has to be a minimum of 2.0V on the ATmega8 or 1.0V on the
                            ATmega168/328 and a max of VCC. So when would you use this? Say your using a 5V to power
                            your AVR. And you're sensors are on a 3.3V power supply. If you want to use the full range
                            you could hook up the 2nd power supply to the AREF pin. How do I know that the min/max on
                            the AREF pin? It's buried in the datasheet under the "ADC Characteristics" table in the
                            "Electrical Characteristics" section of the Datasheet. The other References are AVcc or an
                            internal test voltage. Most of the time you will find yourself using the voltage on AVcc for
                            two reasons. First of all most analog devices are low power consumption devices (so you
                            really don't need to run them off of another power supply for any reason) and secondly
                            because using a reference on VREF prevents us from using the interior sources.
                        </p>

                        <p class="fw-semibold mt-4">ADC Multiplexer Source:</p>
                        <p>
                            Because we only have a single ADC but 6 ADC pins to choose from we need to feed the signal
                            into the ADC using the built-in multiplexer. To do this by setting the MUXn bits in the
                            ADMUX register. The neat thing is that if you change these values while the conversion is
                            running, the conversion will finish before the change takes (so if you ever find yourself
                            having problems with bad data you might be switching before the ADC finishes).
                        </p>

                        <p class="fw-semibold mt-4">ADC Data Register Control:</p>
                        <p>
                            This really got me when I first started playing with micro controllers. Here is the deal.
                            The ADC has 10bit of resolution. However, the AVR is an 8 bit micro controller, so we are
                            always working with 8 bit registers. So in order to get 10bit data we have to split it into
                            2 registers ADCH and ADCL. We can use a 16 bit register or we could use an 8 bit register
                            and dump the bottom 2 bits (which are the least significant bits anyways). If you choose to
                            use the full 10 bits resolution you should leave ADLAR LOW(0) and make sure you <span
                                style="background: yellow">read the ADCL register first</span> because <span
                                style="background: yellow">reading the ADCH causes to ADC to update</span>. If you only
                            want to use 8 bit resolution you will want to set the ADLAR to HIGH(1), this way you only
                            have to read ADCH. I guess I could have said, the ADLAR bit lets you control how the AVR is
                            going to output the data. Set ADLAR HIGH(1) if you only want to 8 bit of resolution.
                        </p>

                        <p class="fw-semibold mt-4">ADC Conversion Timing:</p>
                        <p>
                            The next thing requires a bit of math (and for once it's not a bit of math). In order to get
                            the best conversion results the ADC clock needs to be between 50k - 100k on the ATmega8 and
                            50K-200k on the ATmega168/328. So take your processor clock frequency divide by 100k on the
                            ATmega8 (or 200k on the ATmega168/328). When you get the result move the next highest
                            Division Factor.
                        </p>

                        <div class="ms-4">
                            <p class="fw-semibold mt-4">ATmega8:</p>
                            <p class="ms-4" style="color: blue">
                                Processor Clock Speed / 100k = x (round up to next division factor)
                                <br><br>
                                eg. Using a 8Mhz Clock<br>
                                8MHrz / 100k =<br>
                                8,000,000 / 100,000 = 80<br>
                                next highest = 128
                            </p>
                            <p class="fw-semibold mt-4">ATmega168/328:</p>
                            <p class="ms-4" style="color: blue">
                                Processor Clock Speed / 200k = x (round up to next division factor)
                                <br><br>
                                eg. Using a 1Mhz Clock<br>
                                1MHrz / 200k =<br>
                                1,000,000 / 200,000 = 5<br>
                                next highest = 8
                            </p>
                        </div>

                        <p class="fw-semibold mt-4">Modes of Operation:</p>
                        <p>
                            Now we need to figure out what kind of mode we want to run our ADC in. We can choose to do a
                            single conversion or free running mode. In single mode we do 1 conversion and we are done.
                            In free running mode we run continually, when one conversion finishes we automatically start
                            the next. The default is single conversion mode so we don't have to do a thing. To use Free
                            running mode set the ADFR bit HIGH (1) in the ADCSRA register on the ATmega8 or set the
                            ADATE bit in the ADCSRA register on the ATmega168/328 and leave the ADSTn bits LOW (0) in
                            the ADCSRB register (more on this register later on).
                        </p>
                        <p>
                            There are advantages and disadvantages of both modes. In single scan mode, we tie up the
                            processor while the ADC is doing its conversion, but its simple to use with multiple Analog
                            Inputs because we trigger one at a time. In free running mode, we have to have a bit of
                            extra code to figure out what Analog input just finished and have to make sure we switch the
                            MUX at the right time, it's not too bad, but it is not as simple as single scan mode.
                        </p>

                        <p class="fw-semibold mt-4">ADC Interrupt:</p>
                        <p>
                            Whatever mode you choose to use can be used with, or without interrupts, which will trigger
                            the ADC vector.
                        </p>

                        <p class="fw-semibold mt-4">Special Modes of Operation for the ATmega168/328:</p>
                        <div class="table-responsive">
                            <table class="table table-bordered text-center max-width-600">
                                <thead>
                                <tr>
                                    <th></th>
                                    <th>7 bit</th>
                                    <th>6 bit</th>
                                    <th>5 bit</th>
                                    <th>4 bit</th>
                                    <th>3 bit</th>
                                    <th>2 bit</th>
                                    <th>1 bit</th>
                                    <th>0 bit</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <th>ADCSRB</th>
                                    <td class="disable-cell">-</td>
                                    <td>ACME</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td>ADTS2</td>
                                    <td>ADTS1</td>
                                    <td>ADTS0</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light">ADC Control and Status Register B</p>

                        <div class="table-responsive mt-4 ms-4">
                            <table class="table table-bordered max-width-550">
                                <tbody>
                                <tr>
                                    <th>ADTS2</th>
                                    <th>ADTS1</th>
                                    <th>ADTS0</th>
                                    <th>Trigger Source</th>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td>Free Running</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td>Analog Comparator</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td>External Interrupt Request 0</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td>Timer/Counter0 Compare Match A</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">0</td>
                                    <td>Timer/Counter0 Overflow</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td style="text-align:center">1</td>
                                    <td>Timer/Counter1 Compare Match B</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">0</td>
                                    <td>Timer/Counter1 Overflow</td>
                                </tr>
                                <tr>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td style="text-align:center">1</td>
                                    <td>Timer/Counter1 Capture Event</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light ms-4">ADTS Bits</p>

                        <p>
                            Isn't this cool, on the ATmega168/328 we can use the Timer/Counters and the Analog
                            Comparator as a trigger source to start the ADC conversions. Man does this ever cut down on
                            the coding. Set the ADATE bit in the ADSCRA register to HIGH (1) and set the ADTSn bits in
                            the ADCSRB register the values in the Table, and we are good to go.
                        </p>

                        <div class="table-responsive">
                            <table class="table table-bordered text-center max-width-600">
                                <thead>
                                <tr>
                                    <th></th>
                                    <th>7 bit</th>
                                    <th>6 bit</th>
                                    <th>5 bit</th>
                                    <th>4 bit</th>
                                    <th>3 bit</th>
                                    <th>2 bit</th>
                                    <th>1 bit</th>
                                    <th>0 bit</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <th>DIDR0</th>
                                    <td class="disable-cell">-</td>
                                    <td class="disable-cell">-</td>
                                    <td>ADS5D</td>
                                    <td>ADC4D</td>
                                    <td>ADC3D</td>
                                    <td>ADC2D</td>
                                    <td>ADC1D</td>
                                    <td>ADC0D</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="fw-light">Digital Input Disable Register 0</p>

                        <P>
                            This register is designed to reduce power consumption of the AVR by giving you the ability
                            to turn of the Digital Input circuitry on the 6 ADC pins while your using the ADC. If power
                            consumption is a problem set the bits to HIGH (1) if not leave them at LOW (0).
                        </P>
                    </div>

                    <hr class="mt-4 mb-4"/>
                    <h5 class="fw-semibold">SOFTWARE:</h5>
                    <div class="chapter ms-4 py-2">
                        <p class="fw-semibold mt-4">ADC on The ATmega8:</p>
                        <p>
                            Let's write a bit of code. The two most common ways you will use the ADC is to do a single
                            conversion at a given time in the program and/or to do continue scanning and have it
                            trigger a interrupt when it's done. I'll demonstrate both for each AVR type.
                        </p>
                        <p class="fst-italic mt-4">ATmega8 & ATmega168/328 Code:</p>
                        <pre class="prettyprint linenums lang-c">
    // this code scans ADC1 for an analog signal upon request, using 8Mhz processor clock

    #include &lt;avr/io.h&gt;
    #include &lt;stdint.h&gt;       // needed for uint8_t

    int ADCsingleREAD(uint8_t adctouse)
    {
        int ADCval;

        ADMUX = adctouse;         // use #1 ADC
        ADMUX |= (1 << REFS0);    // use AVcc as the reference
        ADMUX &= ~(1 << ADLAR);   // clear for 10 bit resolution

        ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);    // 128 prescale for 8Mhz
        ADCSRA |= (1 << ADEN);    // Enable the ADC

        ADCSRA |= (1 << ADSC);    // Start the ADC conversion

        while(ADCSRA & (1 << ADSC));      // Thanks T, this line waits for the ADC to finish

        ADCval = ADCL;
        ADCval = (ADCH << 8) + ADCval;    // ADCH is read so ADC can be updated again

        return ADCval;
    }

    int main(void)
    {
        int ADCvalue;

        while (1)
        {
            ADCvalue = ADCsingleREAD(1);
            // ADCvalue now contains an 10bit ADC read
        }
    }</pre>

                        <p class="fst-italic mt-4">ATmega8 Code:</p>
                        <pre class="prettyprint linenums lang-c">
    // this code continually scans ADC0 for an analog signal, using 8Mhz processor clock

    #include &lt;avr/io.h&gt;
    #include &lt;stdint.h&gt;       // needed for uint8_t
    #include &lt;avr/interrupt.h&gt;

    volatile uint8_t ADCvalue;    // Global variable, set to volatile if used with ISR

    int main(void)
    {

        ADMUX = 0;                // use ADC0
        ADMUX |= (1 << REFS0);    // use AVcc as the reference
        ADMUX |= (1 << ADLAR);    // Right adjust for 8 bit resolution

        ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // 128 prescale for 8Mhz
        ADCSRA |= (1 << ADFR);    // Set free running mode
        ADCSRA |= (1 << ADEN);    // Enable the ADC
        ADCSRA |= (1 << ADIE);    // Enable Interrupts

        ADCSRA |= (1 << ADSC);    // Start the ADC conversion

        while (1)
        {
            // main loop
        }
    }


    ISR(ADC_vect)
    {
        ADCvalue = ADCH;          // only need to read the high value for 8 bit

    }</pre>

                        <p class="fw-semibold mt-4">ADC on the ATmega168/328:</p>
                        <p>
                            The ATmega168/328 code isn't much different from the ATmega8 code. If you remember the only
                            difference is that we have a ADATE (ADC Auto Trigger Enable) bit in the ADCSRA register that
                            we use in order that we could then use to set different trigger types (such as Free running
                            mode). For single conversion the code is exactly the same so please read above.
                        </p>

                        <p class="fst-italic mt-4">ATmega168/328 Code:</p>
                        <pre class="prettyprint linenums lang-c">
    // this code continually scans ADC0 for an analog signal, using 16Mhz processor clock

    #include &lt;avr/io.h&gt;
    #include &lt;stdint.h&gt;       // needed for uint8_t
    #include &lt;avr/interrupt.h&gt;

    volatile uint8_t ADCvalue;    // Global variable, set to volatile if used with ISR

    int main(void)
    {

        ADMUX = 0;                // use ADC0
        ADMUX |= (1 << REFS0);    // use AVcc as the reference
        ADMUX |= (1 << ADLAR);    // Right adjust for 8 bit resolution

        ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // 128 prescale for 16Mhz
        ADCSRA |= (1 << ADATE);   // Set ADC Auto Trigger Enable

        ADCSRB = 0;               // 0 for free running mode

        ADCSRA |= (1 << ADEN);    // Enable the ADC
        ADCSRA |= (1 << ADIE);    // Enable Interrupts

        ADCSRA |= (1 << ADSC);    // Start the ADC conversion

        sei();    // Thanks N, forgot this the first time =P

        while (1)
        {
            // main loop
        }
    }

    ISR(ADC_vect)
    {
        ADCvalue = ADCH;          // only need to read the high value for 8 bit
        // REMEMBER: once ADCH is read the ADC will update

        // if you need the value of ADCH in multiple spots, read it into a register
        // and use the register and not the ADCH
    }</pre>

                        <p class="fw-semibold mt-4">Changing MUX While In Free Running Mode With Interrupts:</p>
                        <p>
                            The last thing I want to cover is what if you have sensors on ADC0, ADC1 and ADC2 and you
                            want to run in free running mode. The problem is that you only have 1 ADC and only 1
                            Interrupt vector. So when a interrupt triggers you need to know what sensor is being read
                            AND you need to switch to the next sensor. This could all be done in the ISR routine, so I
                            will just post below. And don't forget to make the Sensor Data Registers volatile.
                        </p>

                        <p class="fst-italic mt-4">ATmega8 & ATmega168/328 Code:</p>
                        <pre class="prettyprint linenums lang-c">
    ISR(ADC_vect)
    {
        uint8_t tmp;            // temp register for storage of misc data

        tmp = ADMUX;            // read the value of ADMUX register
        tmp &= 0x0F;            // AND the first 4 bits (value of ADC pin being used)

        ADCvalue = ADCH;        // read the sensor value

        if (tmp == 0)
        {
            // put ADCvalue into whatever register you use for ADC0 sensor
            ADMUX++;            // add 1 to ADMUX to go to the next sensor
        }

        else if (tmp == 1)
        {
            // put ADCvalue into whatever register you use for ADC1 sensor
            ADMUX++;            // add 1 to ADMUX to go to the next sensor
        }
        else if (tmp == 2)
            // put ADCvalue into whatever register you use for ADC2 sensor
            ADMUX &= 0xF8;      // clear the last 4 bits to reset the mux to ADC0
        }
    }</pre>
                    </div>

                    <hr class="mt-4 mb-4"/>
                    <p>
                        That's it, its over man, that's all I know about ADCs. It's bedtime.
                    </p>
                    <br/>Cheers<br/>Q
                    <div><br/></div>
                    <br/>
                </div>
            </main>
        </div>
    </div>
</div>

<div class="dropdown position-fixed bottom-0 end-0 mb-3 me-3 mode-toggle" id="darkMoodDropdown">
    <button class="btn btn-primary py-2 dropdown-toggle d-flex align-items-center" id="theme" type="button"
            aria-expanded="false" data-bs-toggle="dropdown" aria-label="Toggle theme (light)">
        <svg class="bi my-1 theme-icon-active" width="1em" height="1em">
            <use href="#circle-half"></use>
        </svg>
        <span class="visually-hidden" id="theme-text">Toggle theme</span>
    </button>
    <ul class="dropdown-menu dropdown-menu-end shadow" aria-labelledby="theme-text" id="darkMoodDropdownMenu">
        <li>
            <button type="button" class="dropdown-item d-flex align-items-center" data-mode="light"
                    aria-pressed="false">
                <svg class="bi me-2 opacity-50 theme-icon" width="1em" height="1em">
                    <use href="#sun-fill"></use>
                </svg>
                Light
                <svg class="bi ms-auto d-none" width="1em" height="1em">
                    <use href="#check2"></use>
                </svg>
            </button>
        </li>
        <li>
            <button type="button" class="dropdown-item d-flex align-items-center" data-mode="dark" aria-pressed="false">
                <svg class="bi me-2 opacity-50 theme-icon" width="1em" height="1em">
                    <use href="#moon-stars-fill"></use>
                </svg>
                Dark
                <svg class="bi ms-auto d-none" width="1em" height="1em">
                    <use href="#check2"></use>
                </svg>
            </button>
        </li>
        <li>
            <button type="button" class="dropdown-item d-flex align-items-center active" data-mode="auto"
                    aria-pressed="true">
                <svg class="bi me-2 opacity-50 theme-icon" width="1em" height="1em">
                    <use href="#circle-half"></use>
                </svg>
                Auto
                <svg class="bi ms-auto d-none" width="1em" height="1em">
                    <use href="#check2"></use>
                </svg>
            </button>
        </li>
    </ul>
</div>

<script src="../assets/js/jquery-3.5.1.min.js"></script>
<script src="../assets/js/popper.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>
<script src="../assets/js/main.js"></script>
<script src="../assets/js/prettify.js"></script>

</body>
</html>
